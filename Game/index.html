<!doctype html>
<meta charset="utf-8">
<title>Hello World</title>
<body>
    <script src="pixi.js/bin/pixi.js"></script>
    <script type="text/javascript">

    var stage = new PIXI.Stage(0x000000);
    var renderer = PIXI.autoDetectRenderer(
      512, 512,
      {antialiasing: false, transparent: false, resolution: 1}
    );

    document.body.appendChild(renderer.view);

    // Load tileset
    var loader = new PIXI.AssetLoader([
            "assets/tileset.png",
            "assets/dungeon.png",
            "assets/goblin.png",
            "assets/key.png",
            "assets/door-tile.png"]);
    loader.onComplete = setup;
    loader.load();

    var hero, goblin, dungeon, state, message, door, textures, heroTexture, movementInterval;
    // Function to load tileset and use sprite from it.
    function setup() {

      // Dungeon Texture
      var dungeonTexture = PIXI.TextureCache["assets/dungeon.png"];
      dungeon = new PIXI.Sprite(dungeonTexture);
      stage.addChild(dungeon);

      message = new PIXI.Text(
        "Save the princess!",
        {font: "32px courier", fill: "white"}
      );

      message.position.set(128, 256);
      stage.addChild(message);


      // Create door texture
      var doorTexture = PIXI.TextureCache["assets/door-tile.png"];
      var doorFront = new PIXI.Rectangle(224, 224, 32, 32);

      doorTexture.setFrame(doorFront);

      door = new PIXI.Sprite(doorTexture);

      door.position.set(240, 0);

      door.vy = 5;
      door.vx = 5;
      stage.addChild(door);


      //Create the `tileset` sprite from the texture
      heroTexture = PIXI.TextureCache["assets/tileset.png"];

      //Create a rectangle object that defines the position and
      //size of the sub-image you want to extract from the texture
      textures = {
        hero : {
            front : [new PIXI.Rectangle(188, 128, 30, 30), new PIXI.Rectangle(220, 128, 30, 30), new PIXI.Rectangle(252, 128, 30, 30)],
            back : [new PIXI.Rectangle(188, 224, 30, 30), new PIXI.Rectangle(220, 224, 30, 30), new PIXI.Rectangle(252, 224, 30, 30)],
            right :[new PIXI.Rectangle(188, 192, 30, 30), new PIXI.Rectangle(220, 192, 30, 30), new PIXI.Rectangle(252, 192, 30, 30)],
            left : [new PIXI.Rectangle(188, 160, 30, 30), new PIXI.Rectangle(220, 160, 30, 30), new PIXI.Rectangle(252, 160, 30, 30)]
        }
      };
      console.log(textures);

      //Tell the texture to use that rectangular section
      heroTexture.setFrame(textures.hero.front[0]);

      //Create the sprite from the texture
      hero = new PIXI.Sprite(heroTexture);


      // Goblin
      var goblinTexture = PIXI.TextureCache["assets/goblin.png"];
      var goblinFront = new PIXI.Rectangle(32, 0, 30, 30);

      goblinTexture.setFrame(goblinFront);

      goblin = new PIXI.Sprite(goblinTexture);

      goblin.x = 64;
      goblin.y = 64;

      goblin.vy = 5;
      goblin.vx = 5;
      stage.addChild(goblin);

      //Position the rocket sprite on the canvas
      hero.x = 32;
      hero.y = 32;

      // Handle Keyboard
      //Capture the keyboard arrow keys
      var left = keyboard(37),
      up = keyboard(38),
      right = keyboard(39),
      down = keyboard(40);


      //Left arrow key `press` method
      var interval;


      left.press = function() {
        //Change the hero's velocity when the key is pressed
        hero.vx = -3;
        hero.vy = 0;
        var counter = 0;
        clearInterval(interval);
        heroTexture.setFrame(textures.hero.left[counter]);
        interval = setInterval(function() {
            heroTexture.setFrame(textures.hero.left[counter]);
            counter = (counter + 1) % 3;
        }, 100);
      };

      //Left arrow key `release` method
      left.release = function() {
        //If the left arrow has been released, and the right arrow isn't down,
        //and the hero isn't moving vertically:
        //Stop the hero
        if (!right.isDown && hero.vy === 0) {
          hero.vx = 0;
          clearInterval(interval);
        }
      };

      //Up
      var upTimeout;
      up.press = function() {
        hero.vy = -3;
        hero.vx = 0;
        var counter = 0;
        heroTexture.setFrame(textures.hero.back[counter]);
        clearInterval(interval);
        interval = setInterval(function() {
            heroTexture.setFrame(textures.hero.back[counter]);
            counter = (counter + 1) % 3;
        }, 100);
      };
      up.release = function() {
        if (!down.isDown && hero.vx === 0) {
          hero.vy = 0;
          clearInterval(interval);
        }
      };

      //Right
      var rightTimeout;
      right.press = function() {
        hero.vx = 3;
        hero.vy = 0;
        var counter = 0;
        heroTexture.setFrame(textures.hero.right[counter]);
        clearInterval(interval);
        interval = setInterval(function() {
            heroTexture.setFrame(textures.hero.right[counter]);
            counter = (counter + 1) % 3;
        }, 100);
      };
      right.release = function() {
        if (!left.isDown && hero.vy === 0) {
          hero.vx = 0;
          clearInterval(interval);
        }
      };

      //Down
      var downTimeout;
      down.press = function() {
        hero.vy = 3;
        hero.vx = 0;
        var counter = 0;
        heroTexture.setFrame(textures.hero.front[counter]);
        clearInterval(interval);
        interval = setInterval(function() {
            heroTexture.setFrame(textures.hero.front[counter]);
            counter = (counter + 1) % 3;
        }, 100);
      };
      down.release = function() {
        if (!up.isDown && hero.vx === 0) {
          hero.vy = 0;
          clearInterval(interval);
        }
      };

      // Set velocity
      hero.vx = 0;
      hero.vy = 0;

      // Set game state
      state = play;

      //Add the rocket to the stage
      stage.addChild(hero);

      //Render the stage
      renderer.render(stage);
    }

    function gameLoop() {

      //Loop this function at 60 frames per second
      requestAnimationFrame(gameLoop);

      //Update the current game state
      state();

      //Render the stage to see the animation
      renderer.render(stage);
    }


    function play() {

      //Handle collison
      contain(hero, {x: 28, y: 10, width: 488, height: 480});
      //Move the hero 1 pixel to the right each frame
      hero.x += hero.vx;
      hero.y += hero.vy;


      moveMonster(goblin);


      if (hitTestRectangle(hero, door)) {

      }
      //check for a collision between the cat and the box
      if (hitTestRectangle(hero, goblin)) {

        //if there's a collision, change the message text
        //and tint the box red
        message.setText("hit!");
        hero.tint = 0xff3300;

      } else {

        //if there's no collision, reset the message
        //text and the box's color
        message.setText("No collision...");
        hero.tint = 0xffffff;

      }

    }

    function moveMonster(blob) {

      //Move the blob
      blob.y += blob.vy;

      //Check the blob's screen boundaries
      var blobHitsWall = contain(blob, {x: 28, y: 10, width: 488, height: 480});

      //If the blob hits the top or bottom of the stage, reverse
      //its direction
      if (blobHitsWall === "top" || blobHitsWall === "bottom") {
        blob.vy *= -1;
      }

      //Test for a collision. If any of the enemies are touching
      //the explorer, set `explorerHit` to `true`
      if(hitTestRectangle(hero, blob)) {
        // explorerHit = true;
      }
    }

    function keyboard(keyCode) {
      var key = {};
      key.code = keyCode;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      //The `downHandler`
      key.downHandler = function(event) {
        if (event.keyCode === key.code) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
        }
        event.preventDefault();
      };

      //The `upHandler`
      key.upHandler = function(event) {
        if (event.keyCode === key.code) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
        }
        event.preventDefault();
      };

      //Attach event listeners
      window.addEventListener(
        "keydown", key.downHandler.bind(key), false
      );
      window.addEventListener(
        "keyup", key.upHandler.bind(key), false
      );
      return key;
    }

    function contain(sprite, container) {

      var collision = undefined;

      //Left
      if (sprite.x < container.x) {
        sprite.x = container.x;
        collision = "left";
      }

      //Top
      if (sprite.y < container.y) {
        sprite.y = container.y;
        collision = "top";
      }

      //Right
      if (sprite.x + sprite.width > container.width) {
        sprite.x = container.width - sprite.width;
        collision = "right";
      }

      //Bottom
      if (sprite.y + sprite.height > container.height) {
        sprite.y = container.height - sprite.height;
        collision = "bottom";
      }

      //Return the `collision` value
      return collision;
    }

    function hitTestRectangle(r1, r2) {
      //Define the variables we'll need to calculate
      var hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
      //hit will determine whether there's a collision
      hit = false;
      //Find the center points of each sprite
      r1.centerX = r1.x + r1.width / 2;
      r1.centerY = r1.y + r1.height / 2;
      r2.centerX = r2.x + r2.width / 2;
      r2.centerY = r2.y + r2.height / 2;
      //Find the half-widths and half-heights of each sprite
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;
      //Calculate the distance vector between the sprites
      vx = r1.centerX - r2.centerX;
      vy = r1.centerY - r2.centerY;
      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;
      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {
        //A collision might be occuring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {
          //There's definitely a collision happening
          hit = true;
        } else {
          //There's no collision on the y axis
          hit = false;
        }
      } else {
        //There's no collision on the x axis
        hit = false;
      }
      //`hit` will be either `true` or `false`
      return hit;
    };


    //Start the game loop
    gameLoop();


    </script>
</body>